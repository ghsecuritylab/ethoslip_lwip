/*
    2017 12 31
	@sococos
*/


#include "player.h"

static TaskHandle_t pvCreatedTask1 = NULL;
static volatile uint8_t player_task_run_sflag = 0;
static PLAYER_PAR player_p;

#define AU_FIFO_LEN 1024

struct au_fifo_t {
  	uint16_t start;
	uint16_t end;   //next start
	uint32_t data[AU_FIFO_LEN];
}audio_fifo = {0, 0, 0, };

int au_fifo_get_fill_length(struct au_fifo_t* fifo)
{
  	if(fifo->start <= fifo->end) {
		return fifo->end - fifo->start;
	} else {
	  	return AU_FIFO_LEN - fifo->start + fifo->end;
	}
}

/* len pre 32 bit */
int au_fifo_write(struct au_fifo_t* fifo, void *buffer, uint16_t len)
{
  	if(AU_FIFO_LEN - au_fifo_get_fill_length(fifo) < len) {
		return -1;
	} else if(fifo->len + fifo->end <= AU_FIFO_LEN) {
		memcpy(fifo->data[fifo->end + 1], buffer, len << 2);
	} else {
	  	uint32_t write_size = AU_FIFO_LEN - fifo->end;
	  	memcpy(&fifo->data[fifo->end + 1], buffer, write_size << 2 );
		memcpy(fifo->data, (uint8_t *)buffer + (write_size << 2) , (len - write_size) << 2 );
	}
}

int au_fifo_read(struct au_fifo_t* fifo, void *buffer, uint16_t len) {
  	if(au_fifo_get_fill_length(fifo) < len) {
		return -1;
	} else if(fifo->start + len - 1 <= AU_FIFO_LEN) {
	  	memcpy(buffer, fifo->data[fifo->start], len << 2);
	} else {
	  	uint32_t read_size = AU_FIFO_LEN - fifo->start + 1;
	  	memcpy(buffer, fifo->data[fifo->start], read_size << 2);
		memcpy( (uint8_t *)buffer + (read_size << 2), fifo->data[0], (len - read_size) << 2);
	}
}

void test_task1(void *par)
{
  	//uint8_t buf[32];
  	//static uint8_t wbuf[1024 * 4];
  	uint8_t *wbuf = NULL;
	uint32_t recv_count = 0;
	int n, i;
	
	wbuf = malloc(1024 * 4);
	if(wbuf == NULL) {
	  	player_task_run_sflag = 0;
	  	printf("mem malloc failed\n");
	}
		
	VS_Restart_Play();
	VS_Set_All();
	VS_Reset_DecodeTime();
	vs1003_hdl_spi_init(9000000, 16);  //10416666
	
	int fd = openConn(player_p.server, player_p.path, player_p.port);
	if(fd < 0) {
		//tskreader_enable = 0;
	  	player_task_run_sflag = 0;
		printf("fd failed\n");
	}
	
	int timeout = 6000;
	setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
	
	while(1 == player_task_run_sflag) {
		i = 0;
		n = 0;
		int word;
		
		TickType_t tick1 = xTaskGetTickCount();
		
		
		while(au_fifo_get_fill_length(&audio_fifo) < AU_FIFO_LEN/2 ) {
			int r_len = read(fd, &word, 4);
			//printf("%d ", n);
			if(r_len <= 0) {
			  	player_task_run_sflag = 0;
				printf("socket read timeout 1\n");
				break;
			}
			au_fifo_write(&audio_fifo, &word, 1);
		}
		
		/*do {
			int r_len = read(fd, wbuf + n, 4);
			//printf("%d ", n);
			if(r_len <= 0) {
			  	player_task_run_sflag = 0;
				printf("socket read timeout 1\n");
				break;
			}
			n += r_len;
		}while(n%32 != 0 || n < 1024);*/
		TickType_t tick2 = xTaskGetTickCount();
		printf("[%d]Socket read %d bytes use time %d\n", recv_count, n, tick2 - tick1);
		
		if (n%32 == 0) {
			if(recv_count == 0) {
				int start = php_strpos(wbuf, n, (uint8_t *)"\r\n\r\n", 4, 0);
				if(start < 0) {
					continue;
				}
				if(1){
					int j;
					for(j = 0; j < start + 4; j++) {
						printf("%c", wbuf[j] );
					}
				}
				i = start + 4;
				n = n - start - 4;
				
				timeout = 3000;
				setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
			}
			do {
				if( VS_Send_MusicData(wbuf + i) == 0 ) {
					i += 32;
				}
			}while(i < n );
			recv_count++;
		}
		TickType_t tick3 = xTaskGetTickCount();
		printf("[%d]SPI transfer use time %d\n", recv_count, tick3 - tick2);
			/*if(n == 0) {
				u32 err;
				socklen_t slen = sizeof(err);
				if(!lwip_getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &slen)) {
					printf("MP3: Socket error %d\n", err);
				}
				close(fd);
			}*/
	}
	close(fd);
	free(wbuf);
	wbuf = NULL;
	player_task_run_sflag = 0;
	vTaskDelete(NULL);
}


void player_start(char *server, char *path, const int port)
{
	player_task_run_sflag = 1;
	player_p.server = server;
	player_p.path = path;
	player_p.port = port;
	xTaskCreate(
					test_task1, /* 任务函数 */
					"task 1", /* 任务名 */
					2048, /* 任务栈大小，单位 word，也就是 4 字节 */
					NULL, /* 任务参数 */
					1, /* 任务优先级 */
					&pvCreatedTask1 /* 任务句柄 */
				 );
}

void player_stop()
{
  	player_task_run_sflag = 0;
}

uint8_t player_get_status()
{
  	return player_task_run_sflag;
}



